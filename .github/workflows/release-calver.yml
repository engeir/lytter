name: Release PR with CalVer
on:
  push:
    branches:
      - main
permissions:
  contents: write
  packages: write
  pull-requests: write
jobs:
  release-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Get latest tag
        id: get_tag
        run: |
          # Get the latest tag or use 2025.1.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "2025.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
      - name: Check for changes since last tag
        id: check_changes
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          # Count commits since last tag (excluding merge commits from release PR)
          COMMIT_COUNT=$(git rev-list ${LATEST_TAG}..HEAD --count --no-merges 2>/dev/null || echo "999")
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "Commits since last tag: $COMMIT_COUNT"

          if [ "$COMMIT_COUNT" -eq "0" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
      - name: Generate new CalVer tag
        id: calver
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          # Generate CalVer tag: YYYY.MINOR.PATCH
          YEAR=$(date +%Y)
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"

          # Extract year, minor, patch from latest tag
          if [[ $LATEST_TAG =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            TAG_YEAR="${BASH_REMATCH[1]}"
            TAG_MINOR="${BASH_REMATCH[2]}"
            TAG_PATCH="${BASH_REMATCH[3]}"
          else
            TAG_YEAR="$YEAR"
            TAG_MINOR="0"
            TAG_PATCH="0"
          fi

          # If year changed, reset minor to 1
          if [ "$TAG_YEAR" != "$YEAR" ]; then
            NEW_TAG="$YEAR.1.0"
          else
            # Increment minor version
            NEW_MINOR=$((TAG_MINOR + 1))
            NEW_TAG="$YEAR.$NEW_MINOR.0"
          fi

          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "New tag will be: $NEW_TAG"
      - name: Generate changelog with git-cliff
        id: changelog
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: orhun/git-cliff-action@v4
        with:
          config: cliff.toml
          args: --verbose --unreleased --strip header
        env:
          OUTPUT: CHANGELOG.md
          GITHUB_REPO: ${{ github.repository }}
      - name: Check if release PR exists
        id: check_pr
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          # Check if there's already an open release PR
          PR_NUMBER=$(gh pr list --head release-please --base main --json number --jq '.[0].number')
          if [ -n "$PR_NUMBER" ]; then
            echo "pr_exists=true" >> $GITHUB_OUTPUT
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "Found existing PR #$PR_NUMBER"
          else
            echo "pr_exists=false" >> $GITHUB_OUTPUT
            echo "No existing release PR found"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Create or update release branch
        id: release_branch
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create or update release-please branch
          git checkout -B release-please

          # Update pyproject.toml version
          NEW_VERSION="${{ steps.calver.outputs.new_tag }}"
          sed -i "s/^version = .*/version = \"$NEW_VERSION\"/" pyproject.toml

          # Create/update CHANGELOG.md
          cat > CHANGELOG.md << 'EOF'
          ${{ steps.changelog.outputs.content }}
          EOF

          git add pyproject.toml CHANGELOG.md
          git diff --staged --quiet || git commit -m "chore(release): prepare release $NEW_VERSION"

          # Force push to update the branch
          git push origin release-please --force
      - name: Create or update PR
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          NEW_TAG="${{ steps.calver.outputs.new_tag }}"

          # Create PR body
          PR_BODY="## Release $NEW_TAG

          This PR was automatically generated and will create a new release when merged.

          ### Changes

          ${{ steps.changelog.outputs.content }}

          ---

          **Merging this PR will:**
          - Create tag \`$NEW_TAG\`
          - Create GitHub Release with changelog
          - Build and push Docker images
          - Update version to \`$NEW_TAG\`
          "

          if [ "${{ steps.check_pr.outputs.pr_exists }}" == "true" ]; then
            # Update existing PR
            gh pr edit ${{ steps.check_pr.outputs.pr_number }} \
              --title "chore(release): $NEW_TAG" \
              --body "$PR_BODY"
            echo "Updated existing PR #${{ steps.check_pr.outputs.pr_number }}"
          else
            # Create new PR
            gh pr create \
              --title "chore(release): $NEW_TAG" \
              --body "$PR_BODY" \
              --base main \
              --head release-please \
              --label "release"
            echo "Created new release PR"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # This job runs when the release PR is merged
  create-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, 'chore(release):')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Extract version from commit
        id: extract_version
        run: |
          # Extract version from commit message like "chore(release): prepare release 2025.1.0"
          VERSION=$(echo "${{ github.event.head_commit.message }}" | grep -oP '(?<=release )[0-9]+\.[0-9]+\.[0-9]+' || echo "")
          if [ -z "$VERSION" ]; then
            echo "Could not extract version from commit message"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Creating release for version: $VERSION"
      - name: Create and push tag
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"
      - name: Read changelog
        id: read_changelog
        run: |
          if [ -f CHANGELOG.md ]; then
            echo "changelog<<EOF" >> $GITHUB_OUTPUT
            cat CHANGELOG.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "changelog=Release ${{ steps.extract_version.outputs.version }}" >> $GITHUB_OUTPUT
          fi
      - name: Create GitHub Release
        uses: ncipollo/create-release@v1
        with:
          tag: ${{ steps.extract_version.outputs.version }}
          name: Release ${{ steps.extract_version.outputs.version }}
          body: ${{ steps.read_changelog.outputs.changelog }}
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push Docker image
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker build -f Dockerfile.fastapi -t ghcr.io/engeir/lytter:$VERSION -t ghcr.io/engeir/lytter:latest .
          docker push ghcr.io/engeir/lytter:$VERSION
          docker push ghcr.io/engeir/lytter:latest
      - name: Delete release branch
        run: |
          git push origin --delete release-please || true
